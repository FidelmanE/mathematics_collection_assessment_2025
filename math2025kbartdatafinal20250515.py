# -*- coding: utf-8 -*-
"""Math2025KBARTDataFinal20250515.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hBFAPgtHjXZcGPnMjOQTPADG0htJOH69
"""

import pandas as pd
from google.colab import drive
drive.mount('/content/drive/')

!ls

import re

import sqlite3
conn = sqlite3.connect("MathUsage2025.db")
cursor = conn.cursor()
cursor.execute("DROP TABLE IF EXISTS MathUsage2025")

KBART = pd.read_table('/content/drive/My Drive/Data Services/RAPIDElectronic/2025/May/Kbart.txt', header=0, delimiter='\t', low_memory=False)

column_names = list(KBART.columns.values)
print(column_names)

KBART['online_identifier'] = KBART['online_identifier'].str.replace(' ', '')
KBART['print_identifier'] = KBART['print_identifier'].str.replace(' ', '')
KBART['publication_title'] = KBART['publication_title'].str.strip()

KBART['publication_title'] = KBART['publication_title'].str.replace(r'\s*:\s*', ' : ', regex=True)

KBART.to_sql('KBART', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_KBART_online_identifier ON KBART ([online_identifier]);")
cursor.execute("CREATE INDEX idx_KBART_print_identifier ON KBART ([print_identifier]);")
conn.commit()

FY2020 = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/combined_TR_B1_FY20.xlsx')

FY2020 = FY2020.fillna('')

FY2020['ISBN'] = FY2020['ISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9;]', '', x))

FY2020[FY2020['ISBN'].str.len() > 15].sample(n=10)

FY2020['ISBN'] = FY2020['ISBN'].str.split(';')
FY2020 = FY2020.explode('ISBN', ignore_index=True)
FY2020['ISBN'] = FY2020['ISBN'].str.strip()

FY2020['Print_ISSN'] = FY2020['Print_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2020['Print_ISSN'] = FY2020['Print_ISSN'].str.split(';')
FY2020 = FY2020.explode('Print_ISSN', ignore_index=True)
FY2020['Print_ISSN'] = FY2020['Print_ISSN'].str.strip()

FY2020['Online_ISSN'] = FY2020['Online_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2020['Online_ISSN'] = FY2020['Online_ISSN'].str.split(';')
FY2020 = FY2020.explode('Online_ISSN', ignore_index=True)
FY2020['Online_ISSN'] = FY2020['Online_ISSN'].str.strip()

FY2020.to_sql('FY2020', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_FY2020_ISBN ON FY2020 ([ISBN]);")
cursor.execute("CREATE INDEX idx_FY2020_Online_ISSN ON FY2020 ([Online_ISSN]);")
cursor.execute("CREATE INDEX idx_FY2020_Print_ISSN ON FY2020 ([Print_ISSN]);")
conn.commit()

FY2020UsageByOCN = pd.read_sql("""SELECT DISTINCT [publication_title], [oclc_number], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM
(SELECT [oclc_number], [publication_title], [online_identifier], [print_identifier], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM FY2020 INNER JOIN KBART ON
FY2020.[ISBN]=KBART.[online_identifier] OR FY2020.[ISBN]=KBART.[print_identifier] OR
FY2020.[Online_ISSN]=KBART.[online_identifier] OR FY2020.[Online_ISSN]=KBART.[print_identifier] OR
FY2020.[Print_ISSN]=KBART.[print_identifier] OR FY2020.[Print_ISSN]=KBART.[online_identifier])""", conn)

"""Before joining the original ISBN etc. fields to un-explode them, the results of this query plus the length of results of the NoOCNs query should equal the original FY explosion count except where there are multiple matches on the KB causing rows to duplicate."""

len(FY2020UsageByOCN)

FY2020UsageByOCN = FY2020UsageByOCN.groupby(['oclc_number', 'Metric_Type'])[
    ['publication_title', 'ISBN', 'Online_ISSN', 'Print_ISSN', 'Reporting_Period_Total']
].agg({
    'publication_title': 'first',  # Taking the first publication_title
    'ISBN': lambda x: ';'.join(x.astype(str)),
    'Online_ISSN': lambda x: ';'.join(x.astype(str)),
    'Print_ISSN': lambda x: ';'.join(x.astype(str)),
    # Summing Reporting_Period_Total after coercing to numeric
    'Reporting_Period_Total': lambda x: sum(pd.to_numeric(x, errors='coerce'))
}).reset_index()

FY2020UsageByOCN['oclc_number'] = FY2020UsageByOCN['oclc_number'].astype(int).astype(str)

for col in ['ISBN', 'Online_ISSN', 'Print_ISSN']:
    FY2020UsageByOCN[col] = FY2020UsageByOCN[col].str.replace(r'^;+$', '', regex=True)

FY2020UsageByOCN.head(5)

#FY2020UsageByOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2020UsageByOCN.xlsx', index=False)

FY2020UsageNoOCNs = pd.read_sql("""SELECT DISTINCT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], SUM([Reporting_Period_Total]) FROM
(SELECT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total], [online_identifier], [print_identifier] FROM FY2020 LEFT JOIN KBART ON
FY2020.[ISBN]=KBART.[online_identifier] OR FY2020.[ISBN]=KBART.[print_identifier] OR
FY2020.[Online_ISSN]=KBART.[online_identifier] OR FY2020.[Online_ISSN]=KBART.[print_identifier] OR
FY2020.[Print_ISSN]=KBART.[print_identifier] OR FY2020.[Print_ISSN]=KBART.[online_identifier])
WHERE online_identifier IS NULL AND print_identifier IS NULL
GROUP BY [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type]""", conn)

FY2020UsageNoOCNs.rename(columns={'Title': 'publication_title'})

len(FY2020UsageByOCN)

len(FY2020UsageNoOCNs)

FY2020UsageByOCN.to_sql('FY2020UsageByOCN', conn, if_exists='replace', index=False)
FY2020UsageNoOCNs.to_sql('FY2020UsageNoOCNs', conn, if_exists='replace', index=False)

FY2021 = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/combined_TR_B1_FY21.xlsx')

FY2021 = FY2021.fillna('')

FY2021['ISBN'] = FY2021['ISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9;]', '', x))

FY2021[FY2021['ISBN'].str.len() > 15].sample(n=10)

FY2021['ISBN'] = FY2021['ISBN'].str.split(';')
FY2021 = FY2021.explode('ISBN', ignore_index=True)
FY2021['ISBN'] = FY2021['ISBN'].str.strip()

FY2021['ISBN'].sample(15)

FY2021['Print_ISSN'] = FY2021['Print_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2021['Print_ISSN'] = FY2021['Print_ISSN'].str.split(';')
FY2021 = FY2021.explode('Print_ISSN', ignore_index=True)
FY2021['Print_ISSN'] = FY2021['Print_ISSN'].str.strip()

FY2021['Print_ISSN'].sample(15)

FY2021['Online_ISSN'] = FY2021['Online_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2021['Online_ISSN'] = FY2021['Online_ISSN'].str.split(';')
FY2021 = FY2021.explode('Online_ISSN', ignore_index=True)
FY2021['Online_ISSN'] = FY2021['Online_ISSN'].str.strip()

FY2021['Online_ISSN'].sample(15)

FY2021.to_sql('FY2021', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_FY2021_ISBN ON FY2021 ([ISBN]);")
cursor.execute("CREATE INDEX idx_FY2021_Online_ISSN ON FY2021 ([Online_ISSN]);")
cursor.execute("CREATE INDEX idx_FY2021_Print_ISSN ON FY2021 ([Print_ISSN]);")
conn.commit()

FY2021UsageByOCN = pd.read_sql("""SELECT DISTINCT [publication_title], [oclc_number], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM
(SELECT [oclc_number], [publication_title], [online_identifier], [print_identifier], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM FY2021 INNER JOIN KBART ON
FY2021.[ISBN]=KBART.[online_identifier] OR FY2021.[ISBN]=KBART.[print_identifier] OR
FY2021.[Online_ISSN]=KBART.[online_identifier] OR FY2021.[Online_ISSN]=KBART.[print_identifier] OR
FY2021.[Print_ISSN]=KBART.[print_identifier] OR FY2021.[Print_ISSN]=KBART.[online_identifier])""", conn)

len(FY2021UsageByOCN)

FY2021UsageByOCN = FY2021UsageByOCN.groupby(['oclc_number', 'Metric_Type'])[
    ['publication_title', 'ISBN', 'Online_ISSN', 'Print_ISSN', 'Reporting_Period_Total']
].agg({
    'publication_title': 'first',  # Taking the first publication_title
    'ISBN': lambda x: ';'.join(x.astype(str)),
    'Online_ISSN': lambda x: ';'.join(x.astype(str)),
    'Print_ISSN': lambda x: ';'.join(x.astype(str)),
    # Summing Reporting_Period_Total after coercing to numeric
    'Reporting_Period_Total': lambda x: sum(pd.to_numeric(x, errors='coerce'))
}).reset_index()

FY2021UsageByOCN['oclc_number'] = FY2021UsageByOCN['oclc_number'].astype(int).astype(str)

for col in ['ISBN', 'Online_ISSN', 'Print_ISSN']:
    FY2021UsageByOCN[col] = FY2021UsageByOCN[col].str.replace(r'^;+$', '', regex=True)

FY2021UsageByOCN.head(5)

#FY2021UsageByOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2021UsageByOCN.xlsx', index=False)

FY2021UsageNoOCNs = pd.read_sql("""SELECT DISTINCT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], SUM([Reporting_Period_Total]) FROM
(SELECT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total], [online_identifier], [print_identifier] FROM FY2021 LEFT JOIN KBART ON
FY2021.[ISBN]=KBART.[online_identifier] OR FY2021.[ISBN]=KBART.[print_identifier] OR
FY2021.[Online_ISSN]=KBART.[online_identifier] OR FY2021.[Online_ISSN]=KBART.[print_identifier] OR
FY2021.[Print_ISSN]=KBART.[print_identifier] OR FY2021.[Print_ISSN]=KBART.[online_identifier])
WHERE online_identifier IS NULL AND print_identifier IS NULL
GROUP BY [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type]""", conn)

FY2021UsageNoOCNs.rename(columns={'Title': 'publication_title'})

len(FY2021UsageByOCN)

len(FY2021UsageNoOCNs)

FY2021UsageByOCN.to_sql('FY2021UsageByOCN', conn, if_exists='replace', index=False)
FY2021UsageNoOCNs.to_sql('FY2021UsageNoOCNs', conn, if_exists='replace', index=False)

FY2022 = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/combined_TR_B1_FY22.xlsx')

FY2022 = FY2022.fillna('')

FY2022['ISBN'] = FY2022['ISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9;]', '', x))

FY2022[FY2022['ISBN'].str.len() > 15].sample(n=10)

FY2022['ISBN'] = FY2022['ISBN'].str.split(';')
FY2022 = FY2022.explode('ISBN', ignore_index=True)
FY2022['ISBN'] = FY2022['ISBN'].str.strip()

FY2022['ISBN'].sample(15)

FY2022['Print_ISSN'] = FY2022['Print_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2022['Print_ISSN'] = FY2022['Print_ISSN'].str.split(';')
FY2022 = FY2022.explode('Print_ISSN', ignore_index=True)
FY2022['Print_ISSN'] = FY2022['Print_ISSN'].str.strip()

FY2022['Print_ISSN'].sample(15)

FY2022['Online_ISSN'] = FY2022['Online_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2022['Online_ISSN'] = FY2022['Online_ISSN'].str.split(';')
FY2022 = FY2022.explode('Online_ISSN', ignore_index=True)
FY2022['Online_ISSN'] = FY2022['Online_ISSN'].str.strip()

FY2022['Online_ISSN'].sample(15)

FY2022.to_sql('FY2022', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_FY2022_ISBN ON FY2022 ([ISBN]);")
cursor.execute("CREATE INDEX idx_FY2022_Online_ISSN ON FY2022 ([Online_ISSN]);")
cursor.execute("CREATE INDEX idx_FY2022_Print_ISSN ON FY2022 ([Print_ISSN]);")
conn.commit()

FY2022UsageByOCN = pd.read_sql("""SELECT DISTINCT [publication_title], [oclc_number], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM
(SELECT [oclc_number], [publication_title], [online_identifier], [print_identifier], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM FY2022 INNER JOIN KBART ON
FY2022.[ISBN]=KBART.[online_identifier] OR FY2022.[ISBN]=KBART.[print_identifier] OR
FY2022.[Online_ISSN]=KBART.[online_identifier] OR FY2022.[Online_ISSN]=KBART.[print_identifier] OR
FY2022.[Print_ISSN]=KBART.[print_identifier] OR FY2022.[Print_ISSN]=KBART.[online_identifier])""", conn)

len(FY2022UsageByOCN)

FY2022UsageByOCN = FY2022UsageByOCN.groupby(['oclc_number', 'Metric_Type'])[
    ['publication_title', 'ISBN', 'Online_ISSN', 'Print_ISSN', 'Reporting_Period_Total']
].agg({
    'publication_title': 'first',  # Taking the first publication_title
    'ISBN': lambda x: ';'.join(x.astype(str)),
    'Online_ISSN': lambda x: ';'.join(x.astype(str)),
    'Print_ISSN': lambda x: ';'.join(x.astype(str)),
    # Summing Reporting_Period_Total after coercing to numeric
    'Reporting_Period_Total': lambda x: sum(pd.to_numeric(x, errors='coerce'))
}).reset_index()

FY2022UsageByOCN['oclc_number'] = FY2022UsageByOCN['oclc_number'].astype(int).astype(str)

for col in ['ISBN', 'Online_ISSN', 'Print_ISSN']:
    FY2022UsageByOCN[col] = FY2022UsageByOCN[col].str.replace(r'^;+$', '', regex=True)

FY2022UsageByOCN.head(5)

#FY2022UsageByOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2022UsageByOCN.xlsx', index=False)

FY2022UsageNoOCNs = pd.read_sql("""SELECT DISTINCT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], SUM([Reporting_Period_Total]) FROM
(SELECT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total], [online_identifier], [print_identifier] FROM FY2022 LEFT JOIN KBART ON
FY2022.[ISBN]=KBART.[online_identifier] OR FY2022.[ISBN]=KBART.[print_identifier] OR
FY2022.[Online_ISSN]=KBART.[online_identifier] OR FY2022.[Online_ISSN]=KBART.[print_identifier] OR
FY2022.[Print_ISSN]=KBART.[print_identifier] OR FY2022.[Print_ISSN]=KBART.[online_identifier])
WHERE online_identifier IS NULL AND print_identifier IS NULL
GROUP BY [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type]""", conn)

FY2022UsageNoOCNs.rename(columns={'Title': 'publication_title'})

len(FY2022UsageByOCN)

len(FY2022UsageNoOCNs)

FY2022UsageByOCN.to_sql('FY2022UsageByOCN', conn, if_exists='replace', index=False)
FY2022UsageNoOCNs.to_sql('FY2022UsageNoOCNs', conn, if_exists='replace', index=False)

FY2023 = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/combined_TR_B1_FY23.xlsx')

FY2023 = FY2023.fillna('')

FY2023['ISBN'] = FY2023['ISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9;]', '', x))

FY2023[FY2023['ISBN'].str.len() > 15].sample(n=10)

FY2023['ISBN'] = FY2023['ISBN'].str.split(';')
FY2023 = FY2023.explode('ISBN', ignore_index=True)
FY2023['ISBN'] = FY2023['ISBN'].str.strip()

FY2023['ISBN'].sample(15)

FY2023['Print_ISSN'] = FY2023['Print_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2023['Print_ISSN'] = FY2023['Print_ISSN'].str.split(';')
FY2023 = FY2023.explode('Print_ISSN', ignore_index=True)
FY2023['Print_ISSN'] = FY2023['Print_ISSN'].str.strip()

FY2023['Print_ISSN'].sample(15)

FY2023['Online_ISSN'] = FY2023['Online_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2023['Online_ISSN'] = FY2023['Online_ISSN'].str.split(';')
FY2023 = FY2023.explode('Online_ISSN', ignore_index=True)
FY2023['Online_ISSN'] = FY2023['Online_ISSN'].str.strip()

FY2023['Online_ISSN'].sample(15)

FY2023.to_sql('FY2023', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_FY2023_ISBN ON FY2023 ([ISBN]);")
cursor.execute("CREATE INDEX idx_FY2023_Online_ISSN ON FY2023 ([Online_ISSN]);")
cursor.execute("CREATE INDEX idx_FY2023_Print_ISSN ON FY2023 ([Print_ISSN]);")
conn.commit()

FY2023UsageByOCN = pd.read_sql("""SELECT DISTINCT [publication_title], [oclc_number], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM
(SELECT [oclc_number], [publication_title], [online_identifier], [print_identifier], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM FY2023 INNER JOIN KBART ON
FY2023.[ISBN]=KBART.[online_identifier] OR FY2023.[ISBN]=KBART.[print_identifier] OR
FY2023.[Online_ISSN]=KBART.[online_identifier] OR FY2023.[Online_ISSN]=KBART.[print_identifier] OR
FY2023.[Print_ISSN]=KBART.[print_identifier] OR FY2023.[Print_ISSN]=KBART.[online_identifier])""", conn)

len(FY2023UsageByOCN)

FY2023UsageByOCN = FY2023UsageByOCN.groupby(['oclc_number', 'Metric_Type'])[
    ['publication_title', 'ISBN', 'Online_ISSN', 'Print_ISSN', 'Reporting_Period_Total']
].agg({
    'publication_title': 'first',  # Taking the first publication_title
    'ISBN': lambda x: ';'.join(x.astype(str)),
    'Online_ISSN': lambda x: ';'.join(x.astype(str)),
    'Print_ISSN': lambda x: ';'.join(x.astype(str)),
    # Summing Reporting_Period_Total after coercing to numeric
    'Reporting_Period_Total': lambda x: sum(pd.to_numeric(x, errors='coerce'))
}).reset_index()

FY2023UsageByOCN['oclc_number'] = FY2023UsageByOCN['oclc_number'].astype(int).astype(str)

for col in ['ISBN', 'Online_ISSN', 'Print_ISSN']:
    FY2023UsageByOCN[col] = FY2023UsageByOCN[col].str.replace(r'^;+$', '', regex=True)

FY2023UsageByOCN.head(5)

#FY2023UsageByOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2023UsageByOCN.xlsx', index=False)

FY2023UsageNoOCNs = pd.read_sql("""SELECT DISTINCT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], SUM([Reporting_Period_Total]) FROM
(SELECT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total], [online_identifier], [print_identifier] FROM FY2023 LEFT JOIN KBART ON
FY2023.[ISBN]=KBART.[online_identifier] OR FY2023.[ISBN]=KBART.[print_identifier] OR
FY2023.[Online_ISSN]=KBART.[online_identifier] OR FY2023.[Online_ISSN]=KBART.[print_identifier] OR
FY2023.[Print_ISSN]=KBART.[print_identifier] OR FY2023.[Print_ISSN]=KBART.[online_identifier])
WHERE online_identifier IS NULL AND print_identifier IS NULL
GROUP BY [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type]""", conn)

FY2023UsageNoOCNs.rename(columns={'Title': 'publication_title'})

len(FY2023UsageByOCN)

len(FY2023UsageNoOCNs)

FY2023UsageByOCN.to_sql('FY2023UsageByOCN', conn, if_exists='replace', index=False)
FY2023UsageNoOCNs.to_sql('FY2023UsageNoOCNs', conn, if_exists='replace', index=False)

FY2024 = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/combined_TR_B1_FY24.xlsx')

FY2024 = FY2024.fillna('')

FY2024['ISBN'] = FY2024['ISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9;]', '', x))

FY2024[FY2024['ISBN'].str.len() > 15].sample(n=10)

FY2024['ISBN'] = FY2024['ISBN'].str.split(';')
FY2024 = FY2024.explode('ISBN', ignore_index=True)
FY2024['ISBN'] = FY2024['ISBN'].str.strip()

FY2024['ISBN'].sample(15)

FY2024['Print_ISSN'] = FY2024['Print_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2024['Print_ISSN'] = FY2024['Print_ISSN'].str.split(';')
FY2024 = FY2024.explode('Print_ISSN', ignore_index=True)
FY2024['Print_ISSN'] = FY2024['Print_ISSN'].str.strip()

FY2024['Print_ISSN'].sample(15)

FY2024['Online_ISSN'] = FY2024['Online_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2024['Online_ISSN'] = FY2024['Online_ISSN'].str.split(';')
FY2024 = FY2024.explode('Online_ISSN', ignore_index=True)
FY2024['Online_ISSN'] = FY2024['Online_ISSN'].str.strip()

FY2024['Online_ISSN'].sample(15)

FY2024.to_sql('FY2024', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_FY2024_ISBN ON FY2024 ([ISBN]);")
cursor.execute("CREATE INDEX idx_FY2024_Online_ISSN ON FY2024 ([Online_ISSN]);")
cursor.execute("CREATE INDEX idx_FY2024_Print_ISSN ON FY2024 ([Print_ISSN]);")
conn.commit()

FY2024UsageByOCN = pd.read_sql("""SELECT DISTINCT [publication_title], [oclc_number], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM
(SELECT [oclc_number], [publication_title], [online_identifier], [print_identifier], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM FY2024 INNER JOIN KBART ON
FY2024.[ISBN]=KBART.[online_identifier] OR FY2024.[ISBN]=KBART.[print_identifier] OR
FY2024.[Online_ISSN]=KBART.[online_identifier] OR FY2024.[Online_ISSN]=KBART.[print_identifier] OR
FY2024.[Print_ISSN]=KBART.[print_identifier] OR FY2024.[Print_ISSN]=KBART.[online_identifier])""", conn)

FY2024UsageByOCN = FY2024UsageByOCN.groupby(['oclc_number', 'Metric_Type'])[
    ['publication_title', 'ISBN', 'Online_ISSN', 'Print_ISSN', 'Reporting_Period_Total']
].agg({
    'publication_title': 'first',  # Taking the first publication_title
    'ISBN': lambda x: ';'.join(x.astype(str)),
    'Online_ISSN': lambda x: ';'.join(x.astype(str)),
    'Print_ISSN': lambda x: ';'.join(x.astype(str)),
    # Summing Reporting_Period_Total after coercing to numeric
    'Reporting_Period_Total': lambda x: sum(pd.to_numeric(x, errors='coerce'))
}).reset_index()

FY2024UsageByOCN['oclc_number'] = FY2024UsageByOCN['oclc_number'].astype(int).astype(str)

for col in ['ISBN', 'Online_ISSN', 'Print_ISSN']:
    FY2024UsageByOCN[col] = FY2024UsageByOCN[col].str.replace(r'^;+$', '', regex=True)

FY2024UsageByOCN.head(5)

len(FY2024UsageByOCN)

FY2024UsageNoOCNs = pd.read_sql("""SELECT DISTINCT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], SUM([Reporting_Period_Total]) FROM
(SELECT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total], [online_identifier], [print_identifier] FROM FY2024 LEFT JOIN KBART ON
FY2024.[ISBN]=KBART.[online_identifier] OR FY2024.[ISBN]=KBART.[print_identifier] OR
FY2024.[Online_ISSN]=KBART.[online_identifier] OR FY2024.[Online_ISSN]=KBART.[print_identifier] OR
FY2024.[Print_ISSN]=KBART.[print_identifier] OR FY2024.[Print_ISSN]=KBART.[online_identifier])
WHERE online_identifier IS NULL AND print_identifier IS NULL
GROUP BY [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type]""", conn)

FY2024UsageNoOCNs.rename(columns={'Title': 'publication_title'})

len(FY2024UsageNoOCNs)

FY2024UsageByOCN.to_sql('FY2024UsageByOCN', conn, if_exists='replace', index=False)
FY2024UsageNoOCNs.to_sql('FY2024UsageNoOCNs', conn, if_exists='replace', index=False)

FY2025 = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/combined_TR_B1_FY25.xlsx')

FY2025 = FY2025.fillna('')

FY2025['ISBN'] = FY2025['ISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9;]', '', x))

FY2025['ISBN'] = FY2025['ISBN'].str.split(';')
FY2025 = FY2025.explode('ISBN', ignore_index=True)
FY2025['ISBN'] = FY2025['ISBN'].str.strip()

FY2025['ISBN'].sample(15)

FY2025['Print_ISSN'] = FY2025['Print_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2025['Print_ISSN'] = FY2025['Print_ISSN'].str.split(';')
FY2025 = FY2025.explode('Print_ISSN', ignore_index=True)
FY2025['Print_ISSN'] = FY2025['Print_ISSN'].str.strip()

FY2025['Print_ISSN'].sample(15)

FY2025['Online_ISSN'] = FY2025['Online_ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-;]', '', x))
FY2025['Online_ISSN'] = FY2025['Online_ISSN'].str.split(';')
FY2025 = FY2025.explode('Online_ISSN', ignore_index=True)
FY2025['Online_ISSN'] = FY2025['Online_ISSN'].str.strip()

FY2025['Online_ISSN'].sample(15)

FY2025.to_sql('FY2025', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_FY2025_ISBN ON FY2025 ([ISBN]);")
cursor.execute("CREATE INDEX idx_FY2025_Online_ISSN ON FY2025 ([Online_ISSN]);")
cursor.execute("CREATE INDEX idx_FY2025_Print_ISSN ON FY2025 ([Print_ISSN]);")
conn.commit()

FY2025UsageByOCN = pd.read_sql("""SELECT DISTINCT [publication_title], [oclc_number], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM
(SELECT [oclc_number], [publication_title], [online_identifier], [print_identifier], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total] FROM FY2025 INNER JOIN KBART ON
FY2025.[ISBN]=KBART.[online_identifier] OR FY2025.[ISBN]=KBART.[print_identifier] OR
FY2025.[Online_ISSN]=KBART.[online_identifier] OR FY2025.[Online_ISSN]=KBART.[print_identifier] OR
FY2025.[Print_ISSN]=KBART.[print_identifier] OR FY2025.[Print_ISSN]=KBART.[online_identifier])""", conn)

FY2025UsageByOCN = FY2025UsageByOCN.groupby(['oclc_number', 'Metric_Type'])[
    ['publication_title', 'ISBN', 'Online_ISSN', 'Print_ISSN', 'Reporting_Period_Total']
].agg({
    'publication_title': 'first',  # Taking the first publication_title
    'ISBN': lambda x: ';'.join(x.astype(str)),
    'Online_ISSN': lambda x: ';'.join(x.astype(str)),
    'Print_ISSN': lambda x: ';'.join(x.astype(str)),
    # Summing Reporting_Period_Total after coercing to numeric
    'Reporting_Period_Total': lambda x: sum(pd.to_numeric(x, errors='coerce'))
}).reset_index()

FY2025UsageByOCN['oclc_number'] = FY2025UsageByOCN['oclc_number'].astype(int).astype(str)

for col in ['ISBN', 'Online_ISSN', 'Print_ISSN']:
    FY2025UsageByOCN[col] = FY2025UsageByOCN[col].str.replace(r'^;+$', '', regex=True)

FY2025UsageByOCN.head(5)

len(FY2025UsageByOCN)

FY2025UsageNoOCNs = pd.read_sql("""SELECT DISTINCT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], SUM([Reporting_Period_Total]) FROM
(SELECT [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type], [Reporting_Period_Total], [online_identifier], [print_identifier] FROM FY2025 LEFT JOIN KBART ON
FY2025.[ISBN]=KBART.[online_identifier] OR FY2025.[ISBN]=KBART.[print_identifier] OR
FY2025.[Online_ISSN]=KBART.[online_identifier] OR FY2025.[Online_ISSN]=KBART.[print_identifier] OR
FY2025.[Print_ISSN]=KBART.[print_identifier] OR FY2025.[Print_ISSN]=KBART.[online_identifier])
WHERE online_identifier IS NULL AND print_identifier IS NULL
GROUP BY [Title], [ISBN], [Print_ISSN], [Online_ISSN], [Metric_Type]""", conn)

FY2025UsageNoOCNs.rename(columns={'Title': 'publication_title'})

len(FY2025UsageNoOCNs)

FY2025UsageByOCN.to_sql('FY2025UsageByOCN', conn, if_exists='replace', index=False)
FY2025UsageNoOCNs.to_sql('FY2025UsageNoOCNs', conn, if_exists='replace', index=False)

"""Read in Subject Data from prior MARC analysis"""

colnamesc = ['OCN', 'LDR06', 'LDR07', 'Author', 'sISBN', 'ISSN', 'field00807', 'field00808',
                'field00809', 'field00810', 'field00811', 'field00812', 'field00813',
                'field00814', 'field00823', 'subjectlist',
                'field050alist', 'field050blist', 'Format', 'oclc_collection_name', 'Date1', 'Date2', 'title']

SubjectDatawithISBNandISSN = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025SubjectData/AllHoldingsWithSHswithISSNandISBN.xlsx', usecols=colnamesc)

print(SubjectDatawithISBNandISSN.columns)

SubjectDatawithISBNandISSN.to_sql('SubjectDatawithISBNandISSN', conn, if_exists='replace', index=False)

cursor = conn.cursor()

# Define the tables and columns to index
tables_to_index_ocn = [
    'FY2020UsageByOCN',
    'FY2021UsageByOCN',
    'FY2022UsageByOCN',
    'FY2023UsageByOCN',
    'FY2024UsageByOCN',
    'FY2025UsageByOCN'
]
column_ocn = 'oclc_number'

tables_to_index_OCN_subject = ['SubjectDatawithISBNandISSN']
column_OCN_subject = 'OCN'

# Create indexes for oclc_number in FY202xUsageByOCN tables
for table in tables_to_index_ocn:
    index_name = f'idx_{table}_{column_ocn}'
    try:
        cursor.execute(f"CREATE INDEX {index_name} ON {table} ([{column_ocn}]);")
        print(f"Index '{index_name}' created successfully on table '{table}'.")
    except sqlite3.OperationalError as e:
        print(f"Index '{index_name}' on table '{table}' already exists or there was an error: {e}")

# Create index for OCN in SubjectDatawithISBNandISSN table
for table in tables_to_index_OCN_subject:
    index_name = f'idx_{table}_{column_OCN_subject}'
    try:
        cursor.execute(f"CREATE INDEX {index_name} ON {table} ([{column_OCN_subject}]);")
        print(f"Index '{index_name}' created successfully on table '{table}'.")
    except sqlite3.OperationalError as e:
        print(f"Index '{index_name}' on table '{table}' already exists or there was an error: {e}")


# Commit the changes
conn.commit()

"""Join Usage tables to Subject Data on OCN for each year's individual sheet and for all years."""

FY2020UsagebySubjectonOCN =  pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2020UsageByOCN ON SubjectDatawithISBNandISSN.[OCN]=FY2020UsageByOCN.[oclc_number]""", conn)

#FY2020UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2020UsagebySubjectonOCN.xlsx')

FY2021UsagebySubjectonOCN =  pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2021UsageByOCN ON SubjectDatawithISBNandISSN.[OCN]=FY2021UsageByOCN.[oclc_number]""", conn)

#FY2021UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2021UsagebySubjectonOCN.xlsx')

FY2022UsagebySubjectonOCN =  pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2022UsageByOCN ON SubjectDatawithISBNandISSN.[OCN]=FY2022UsageByOCN.[oclc_number]""", conn)

#FY2022UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2022UsagebySubjectonOCN.xlsx')

FY2023UsagebySubjectonOCN =  pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2023UsageByOCN ON SubjectDatawithISBNandISSN.[OCN]=FY2023UsageByOCN.[oclc_number]""", conn)

#FY2023UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2023UsagebySubjectonOCN.xlsx')

FY2024UsagebySubjectonOCN =  pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2024UsageByOCN ON SubjectDatawithISBNandISSN.[OCN]=FY2024UsageByOCN.[oclc_number]""", conn)

#FY2024UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2024UsagebySubjectonOCN.xlsx')

FY2025UsagebySubjectonOCN =  pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2025UsageByOCN ON SubjectDatawithISBNandISSN.[OCN]=FY2025UsageByOCN.[oclc_number]""", conn)

#FY2025UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FY2025UsagebySubjectonOCN.xlsx')

UsagebyOCNList = [FY2020UsageByOCN, FY2021UsageByOCN, FY2022UsageByOCN, FY2023UsageByOCN, FY2024UsageByOCN, FY2025UsageByOCN]

UsagebyOCNAllYears = pd.concat(UsagebyOCNList, ignore_index=True)

UsagebyOCNAllYears.to_sql('UsagebyOCNAllYears', conn, if_exists='replace', index=False)

UsagebySubjectonOCN = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN UsageByOCNAllYears ON SubjectDatawithISBNandISSN.[OCN]=UsageByOCNAllYears.[oclc_number]""", conn)

#UsagebySubjectonOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/UsagebySubjectonOCN.xlsx')

"""Join NoOCNs tables to Subject Data on ISBN"""

cursor = conn.cursor()

# Define the list of tables and columns to index
tables_to_index = [
    'FY2020UsageNoOCNs',
    'FY2021UsageNoOCNs',
    'FY2022UsageNoOCNs',
    'FY2023UsageNoOCNs',
    'FY2024UsageNoOCNs',
    'FY2025UsageNoOCNs'
]
columns_to_index = ['ISBN', 'Online_ISSN', 'Print_ISSN']

# Iterate through tables and columns to create indexes
for table in tables_to_index:
    for column in columns_to_index:
        index_name = f'idx_{table}_{column}'
        try:
            cursor.execute(f"CREATE INDEX {index_name} ON {table} ([{column}]);")
            print(f"Index '{index_name}' created successfully on table '{table}'.")
        except sqlite3.OperationalError as e:
            print(f"Index '{index_name}' on table '{table}' already exists or there was an error: {e}")

# Commit the changes
conn.commit()

SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str).apply(lambda x: re.sub(r'[^0-9,]', '', x))
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].str.replace(r',+', ',', regex=True)

SubjectDatawithISBNandISSN['sISBN'].head(4)

SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].str.split(',')
SubjectDatawithISBNandISSN = SubjectDatawithISBNandISSN.explode('sISBN', ignore_index=True)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].str.strip()  # Remove leading/trailing spaces

SubjectDatawithISBNandISSN = SubjectDatawithISBNandISSN[SubjectDatawithISBNandISSN['sISBN'] != "No ISBN"]

SubjectDatawithISBNandISSN = SubjectDatawithISBNandISSN[SubjectDatawithISBNandISSN['sISBN'] != '']

SubjectDatawithISBNandISSN.to_sql('SubjectDatawithISBNandISSN', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_SubjectDatawithISBNandISSN_sISBN ON SubjectDatawithISBNandISSN ([sISBN]);")
conn.commit()

#Save this block for future RAM crashes :-)
chunksize = 10000

# SQL query to perform the join in SQLite
join_query = """
SELECT T1.*, T2.*
FROM SubjectDatawithISBNandISSN AS T1
INNER JOIN FY2020UsageNoOCNs AS T2
ON T1.[sISBN] = T2.[ISBN]
"""

# Load the result in chunks
all_joined_chunks = []
for chunk in pd.read_sql(join_query, conn, chunksize=chunksize):
    all_joined_chunks.append(chunk)

# Concatenate the chunks into a single DataFrame
FY2020UsagebySubjectNoOCNs = pd.concat(all_joined_chunks, ignore_index=True)

FY2020UsagebySubjectNoOCNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2020UsageNoOCNs ON SubjectDatawithISBNandISSN.[sISBN]=FY2020UsageNoOCNs.[ISBN]""", conn)

FY2021UsagebySubjectNoOCNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2021UsageNoOCNs ON SubjectDatawithISBNandISSN.[sISBN]=FY2021UsageNoOCNs.[ISBN]""", conn)

FY2022UsagebySubjectNoOCNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2022UsageNoOCNs ON SubjectDatawithISBNandISSN.[sISBN]=FY2022UsageNoOCNs.[ISBN]""", conn)

FY2023UsagebySubjectNoOCNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2023UsageNoOCNs ON SubjectDatawithISBNandISSN.[sISBN]=FY2023UsageNoOCNs.[ISBN]""", conn)

FY2024UsagebySubjectNoOCNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2024UsageNoOCNs ON SubjectDatawithISBNandISSN.[sISBN]=FY2024UsageNoOCNs.[ISBN]""", conn)

FY2025UsagebySubjectNoOCNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2025UsageNoOCNs ON SubjectDatawithISBNandISSN.[sISBN]=FY2025UsageNoOCNs.[ISBN]""", conn)

UsageNoOCNList = [FY2020UsageNoOCNs, FY2021UsageNoOCNs, FY2022UsageNoOCNs, FY2023UsageNoOCNs, FY2024UsageNoOCNs, FY2025UsageNoOCNs]

UsageNoOCNAllYears = pd.concat(UsageNoOCNList, ignore_index=True)

UsageNoOCNAllYears = UsageNoOCNAllYears.rename(columns={'Title': 'publication_title'})

UsageNoOCNAllYears.to_sql('UsageNoOCNAllYears', conn, if_exists='replace', index=False)

UsagebySubjectNoOCN = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN UsageNoOCNAllYears ON SubjectDatawithISBNandISSN.[sISBN]=UsageNoOCNAllYears.[ISBN]""", conn)

#UsagebySubjectNoOCN.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/UsagebySubjectNoOCN.xlsx')

FY2020UsagebySubjectNoISBN =  pd.read_sql("""SELECT * FROM FY2020UsageNoOCNs LEFT JOIN SubjectDatawithISBNandISSN ON FY2020UsageNoOCNs.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

FY2021UsagebySubjectNoISBN =  pd.read_sql("""SELECT * FROM FY2021UsageNoOCNs LEFT JOIN SubjectDatawithISBNandISSN ON FY2021UsageNoOCNs.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

FY2022UsagebySubjectNoISBN =  pd.read_sql("""SELECT * FROM FY2022UsageNoOCNs LEFT JOIN SubjectDatawithISBNandISSN ON FY2022UsageNoOCNs.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

FY2023UsagebySubjectNoISBN =  pd.read_sql("""SELECT * FROM FY2023UsageNoOCNs LEFT JOIN SubjectDatawithISBNandISSN ON FY2023UsageNoOCNs.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

FY2024UsagebySubjectNoISBN =  pd.read_sql("""SELECT * FROM FY2024UsageNoOCNs LEFT JOIN SubjectDatawithISBNandISSN ON FY2024UsageNoOCNs.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

FY2025UsagebySubjectNoISBN =  pd.read_sql("""SELECT * FROM FY2025UsageNoOCNs LEFT JOIN SubjectDatawithISBNandISSN ON FY2025UsageNoOCNs.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

UsagebySubjectNoISBN = pd.read_sql("""SELECT * FROM UsageNoOCNAllYears LEFT JOIN SubjectDatawithISBNandISSN ON UsageNoOCNAllYears.[ISBN]=SubjectDatawithISBNandISSN.[sISBN] WHERE SubjectDatawithISBNandISSN.[sISBN] IS Null""", conn)

FY2020UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2021UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2022UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2023UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2024UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2025UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)
UsagebySubjectNoISBN.rename(columns={'Title': 'publication_title'}, inplace=True)

FY2020UsagebySubjectNoISBN.to_sql('FY2020UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

FY2021UsagebySubjectNoISBN.to_sql('FY2021UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

FY2022UsagebySubjectNoISBN.to_sql('FY2022UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

FY2023UsagebySubjectNoISBN.to_sql('FY2023UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

FY2024UsagebySubjectNoISBN.to_sql('FY2024UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

FY2025UsagebySubjectNoISBN.to_sql('FY2025UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

UsagebySubjectNoISBN.to_sql('UsagebySubjectNoISBN', conn, if_exists='replace', index=False)

SubjectDatawithISBNandISSN = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025SubjectData/AllHoldingsWithSHswithISSNandISBN.xlsx', usecols=colnamesc)

SubjectDatawithISBNandISSN['ISSN'] = SubjectDatawithISBNandISSN['ISSN'].astype(str).apply(lambda x: re.sub(r'[^\d\-,]', '', x))
SubjectDatawithISBNandISSN['ISSN'] = SubjectDatawithISBNandISSN['ISSN'].str.replace(r'[-,]+', '-', regex=True)

#SubjectDatawithISBNandISSN[SubjectDatawithISBNandISSN['ISSN'].astype(str) != ''].sample(5)

SubjectDatawithISBNandISSN['ISSN'] = SubjectDatawithISBNandISSN['ISSN'].str.split(',')
SubjectDatawithISBNandISSN = SubjectDatawithISBNandISSN.explode('ISSN', ignore_index=True)
SubjectDatawithISBNandISSN['ISSN'] = SubjectDatawithISBNandISSN['ISSN'].str.strip()  # Remove leading/trailing spaces

SubjectDatawithISBNandISSN = SubjectDatawithISBNandISSN[(SubjectDatawithISBNandISSN['ISSN'] != "No ISSN") & (SubjectDatawithISBNandISSN['ISSN'] != '')]

SubjectDatawithISBNandISSN.to_sql('SubjectDatawithISBNandISSN', conn, if_exists='replace', index=False)

cursor = conn.cursor()
cursor.execute("CREATE INDEX idx_SubjectDatawithISBNandISSN_ISSN ON SubjectDatawithISBNandISSN ([ISSN]);")
conn.commit()

FY2020UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2020UsageBySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=FY2020UsageBySubjectNoISBN.[Print_ISSN]""", conn)

FY2021UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2021UsageBySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=FY2021UsageBySubjectNoISBN.[Print_ISSN]""", conn)

FY2022UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2022UsageBySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=FY2022UsageBySubjectNoISBN.[Print_ISSN]""", conn)

FY2023UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2023UsageBySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=FY2023UsageBySubjectNoISBN.[Print_ISSN]""", conn)

FY2024UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2024UsageBySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=FY2024UsageBySubjectNoISBN.[Print_ISSN]""", conn)

FY2025UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2025UsageBySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=FY2025UsageBySubjectNoISBN.[Print_ISSN]""", conn)

UsageBySubjectPrintISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN UsagebySubjectNoISBN ON SubjectDatawithISBNandISSN.[ISSN]=UsagebySubjectNoISBN.[Print_ISSN]""", conn)

#UsageBySubjectPrintISSNs.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/UsageBySubjectPrintISSNs.xlsx')

FY2020UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM FY2020UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON FY2020UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2021UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM FY2021UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON FY2021UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2022UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM FY2022UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON FY2022UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2023UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM FY2023UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON FY2023UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2024UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM FY2024UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON FY2024UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2025UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM FY2025UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON FY2025UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

UsageBySubjectNoPrintISSN = pd.read_sql("""SELECT * FROM UsageBySubjectNoISBN LEFT JOIN SubjectDatawithISBNandISSN ON UsageBySubjectNoISBN.[Print_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2020UsageBySubjectNoPrintISSN = FY2020UsageBySubjectNoPrintISSN.loc[:, ~FY2020UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

FY2021UsageBySubjectNoPrintISSN = FY2021UsageBySubjectNoPrintISSN.loc[:, ~FY2021UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

FY2022UsageBySubjectNoPrintISSN = FY2022UsageBySubjectNoPrintISSN.loc[:, ~FY2022UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

FY2023UsageBySubjectNoPrintISSN = FY2023UsageBySubjectNoPrintISSN.loc[:, ~FY2023UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

FY2024UsageBySubjectNoPrintISSN = FY2024UsageBySubjectNoPrintISSN.loc[:, ~FY2024UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

FY2025UsageBySubjectNoPrintISSN = FY2025UsageBySubjectNoPrintISSN.loc[:, ~FY2025UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

FY2020UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2021UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2022UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2023UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2024UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)
FY2025UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)
UsageBySubjectNoPrintISSN.rename(columns={'Title': 'publication_title'}, inplace=True)

FY2020UsageBySubjectNoPrintISSN.to_sql('FY2020UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)
FY2021UsageBySubjectNoPrintISSN.to_sql('FY2021UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)
FY2022UsageBySubjectNoPrintISSN.to_sql('FY2022UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)
FY2023UsageBySubjectNoPrintISSN.to_sql('FY2023UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)
FY2024UsageBySubjectNoPrintISSN.to_sql('FY2024UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)
FY2025UsageBySubjectNoPrintISSN.to_sql('FY2025UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)

UsageBySubjectNoPrintISSN = UsageBySubjectNoPrintISSN.loc[:, ~UsageBySubjectNoPrintISSN.columns.duplicated(keep='first')]

UsageBySubjectNoPrintISSN.to_sql('UsageBySubjectNoPrintISSN', conn, if_exists='replace', index=False)

FY2020UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2020UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=FY2020UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

FY2021UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2021UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=FY2021UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

FY2022UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2022UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=FY2022UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

FY2023UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2023UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=FY2023UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

FY2024UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2024UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=FY2024UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

FY2025UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN FY2025UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=FY2025UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

UsageBySubjectOnlineISSNs = pd.read_sql("""SELECT * FROM SubjectDatawithISBNandISSN INNER JOIN UsageBySubjectNoPrintISSN ON SubjectDatawithISBNandISSN.[ISSN]=UsageBySubjectNoPrintISSN.[Online_ISSN]""", conn)

#UsageBySubjectOnlineISSNs.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/UsageBySubjectOnlineISSNs.xlsx')

FY2020UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM FY2020UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON FY2020UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2021UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM FY2021UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON FY2021UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2022UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM FY2022UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON FY2022UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2023UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM FY2023UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON FY2023UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2024UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM FY2024UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON FY2024UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

FY2025UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM FY2025UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON FY2025UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

UsageBySubjectNoOnlineISSNs = pd.read_sql("""SELECT * FROM UsageBySubjectNoPrintISSN LEFT JOIN SubjectDatawithISBNandISSN ON UsageBySubjectNoPrintISSN.[Online_ISSN]=SubjectDatawithISBNandISSN.[ISSN] WHERE SubjectDatawithISBNandISSN.[ISSN] Is Null""", conn)

#UsageBySubjectNoOnlineISSNs.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/UsageBySubjectNoOnlineISSNs.xlsx')

"""Concatenate UsageBySubjectonOCN, UsageBySubjectNoOCN, UsageBySubjectPrintISSNs, UsageBySubjectOnlineISSNs"""

UsagebySubjectonOCN = UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
UsagebySubjectonOCN = UsagebySubjectonOCN[current_columns]

UsageBySubjectPrintISSNs = UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

UsageBySubjectOnlineISSNs = UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

UsageBySubjectOnlineISSNs.columns

UsageBySubjectPrintISSNs = UsageBySubjectPrintISSNs.loc[:,~UsageBySubjectPrintISSNs.columns.duplicated()]
UsageBySubjectOnlineISSNs = UsageBySubjectOnlineISSNs.loc[:,~UsageBySubjectOnlineISSNs.columns.duplicated()]

AllMathUsage = pd.concat([
    UsagebySubjectonOCN,
    UsagebySubjectNoOCN,
    UsageBySubjectPrintISSNs,
    UsageBySubjectOnlineISSNs
], ignore_index=True)

len(AllMathUsage)

#AllMathUsage.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/AllMathUsage.xlsx')

columns_to_drop = ['publication_title', 'SUM([Reporting_Period_Total])']
AllMathUsage = AllMathUsage.drop(columns=columns_to_drop, axis=1)

AllMathUsage.to_sql('AllMathUsage', conn, if_exists='replace', index=False)

AllMathUsage.columns

SubjectDatawithISBNandISSN = pd.read_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025SubjectData/AllHoldingsWithSHswithISSNandISBN.xlsx', usecols=colnamesc)

len(SubjectDatawithISBNandISSN)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in AllMathUsage.columns:
    ocns_to_exclude.update(AllMathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in AllMathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(AllMathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in AllMathUsage.")


isbns_to_exclude = set()
if 'ISBN' in AllMathUsage.columns:
    isbns_to_exclude.update(AllMathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in AllMathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
AllMathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
AllMathNonUsage = AllMathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in AllMathNonUsage: {len(AllMathNonUsage)}")

#AllMathNonUsage = pd.read_sql("""SELECT SubjectDatawithISBNandISSN.*, AllMathUsage.[ISBN], AllMathUsage.[Online_ISSN], AllMathUsage.[Print_ISSN], AllMathUsage.[Metric_Type], AllMathUsage.[Reporting_Period_Total] FROM SubjectDatawithISBNandISSN LEFT JOIN AllMathUsage ON SubjectDatawithISBNandISSN.[OCN]=AllMathUsage.[OCN] OR SubjectDatawithISBNandISSN.[sISBN]=AllMathUsage.[ISBN] WHERE AllMathUsage.[OCN] Is Null AND AllMathUsage.[ISBN] Is Null""", conn)

AllMathNonUsage.columns

len(AllMathNonUsage)

AllMathUsage = AllMathUsage.reset_index(drop=True)
AllMathNonUsage = AllMathNonUsage.reset_index(drop=True)

FinalMathUsageData = pd.concat([AllMathUsage, AllMathNonUsage], ignore_index=True)

FinalMathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalMathUsageData.xlsx')

"""Individual years"""

FY2020UsagebySubjectonOCN = FY2020UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = FY2020UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
FY2020UsagebySubjectonOCN = FY2020UsagebySubjectonOCN[current_columns]

FY2020UsageBySubjectPrintISSNs = FY2020UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

FY2020UsageBySubjectOnlineISSNs = FY2020UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

FY2020UsageBySubjectOnlineISSNs.columns

FY2020UsageBySubjectPrintISSNs = FY2020UsageBySubjectPrintISSNs.loc[:,~FY2020UsageBySubjectPrintISSNs.columns.duplicated()]
FY2020UsageBySubjectOnlineISSNs = FY2020UsageBySubjectOnlineISSNs.loc[:,~FY2020UsageBySubjectOnlineISSNs.columns.duplicated()]

FY2020MathUsage = pd.concat([
    FY2020UsagebySubjectonOCN,
    FY2020UsagebySubjectNoOCNs,
    FY2020UsageBySubjectPrintISSNs,
    FY2020UsageBySubjectOnlineISSNs
], ignore_index=True)

len(FY2020MathUsage)

FY2020MathUsage.columns

columns_to_drop = ['Title', 'SUM([Reporting_Period_Total])']
FY2020MathUsage = FY2020MathUsage.drop(columns=columns_to_drop, axis=1)

FY2020MathUsage.to_sql('FY2020MathUsage', conn, if_exists='replace', index=False)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in FY2020MathUsage.columns:
    ocns_to_exclude.update(FY2020MathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in FY2020MathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(FY2020MathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in FY2020MathUsage.")


isbns_to_exclude = set()
if 'ISBN' in FY2020MathUsage.columns:
    isbns_to_exclude.update(FY2020MathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in FY2020MathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
FY2020MathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
FY2020MathNonUsage = FY2020MathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in FY2020MathNonUsage: {len(FY2020MathNonUsage)}")

FinalFY2020MathUsageData = pd.concat([FY2020MathUsage, FY2020MathNonUsage], ignore_index=True)

FinalFY2020MathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalFY2020MathUsageData.xlsx')

FY2021UsagebySubjectonOCN = FY2021UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = FY2021UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
FY2021UsagebySubjectonOCN = FY2021UsagebySubjectonOCN[current_columns]

FY2021UsageBySubjectPrintISSNs = FY2021UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

FY2021UsageBySubjectOnlineISSNs = FY2021UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

FY2021UsageBySubjectOnlineISSNs.columns

FY2021UsageBySubjectPrintISSNs = FY2021UsageBySubjectPrintISSNs.loc[:,~FY2021UsageBySubjectPrintISSNs.columns.duplicated()]
FY2021UsageBySubjectOnlineISSNs = FY2021UsageBySubjectOnlineISSNs.loc[:,~FY2021UsageBySubjectOnlineISSNs.columns.duplicated()]

FY2021MathUsage = pd.concat([
    FY2021UsagebySubjectonOCN,
    FY2021UsagebySubjectNoOCNs,
    FY2021UsageBySubjectPrintISSNs,
    FY2021UsageBySubjectOnlineISSNs
], ignore_index=True)

len(FY2021MathUsage)

FY2021MathUsage.columns

columns_to_drop = ['Title', 'SUM([Reporting_Period_Total])']
FY2021MathUsage = FY2021MathUsage.drop(columns=columns_to_drop, axis=1)

FY2021MathUsage.to_sql('FY2021MathUsage', conn, if_exists='replace', index=False)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in FY2021MathUsage.columns:
    ocns_to_exclude.update(FY2021MathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in FY2021MathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(FY2021MathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in FY2021MathUsage.")


isbns_to_exclude = set()
if 'ISBN' in FY2021MathUsage.columns:
    isbns_to_exclude.update(FY2021MathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in FY2021MathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
FY2021MathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
FY2021MathNonUsage = FY2021MathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in FY2021MathNonUsage: {len(FY2021MathNonUsage)}")

FinalFY2021MathUsageData = pd.concat([FY2021MathUsage, FY2021MathNonUsage], ignore_index=True)

FinalFY2021MathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalFY2021MathUsageData.xlsx')

FY2022UsagebySubjectonOCN = FY2022UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = FY2022UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
FY2022UsagebySubjectonOCN = FY2022UsagebySubjectonOCN[current_columns]

FY2022UsageBySubjectPrintISSNs = FY2022UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

FY2022UsageBySubjectOnlineISSNs = FY2022UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

FY2022UsageBySubjectOnlineISSNs.columns

FY2022UsageBySubjectPrintISSNs = FY2022UsageBySubjectPrintISSNs.loc[:,~FY2022UsageBySubjectPrintISSNs.columns.duplicated()]
FY2022UsageBySubjectOnlineISSNs = FY2022UsageBySubjectOnlineISSNs.loc[:,~FY2022UsageBySubjectOnlineISSNs.columns.duplicated()]

FY2022MathUsage = pd.concat([
    FY2022UsagebySubjectonOCN,
    FY2022UsagebySubjectNoOCNs,
    FY2022UsageBySubjectPrintISSNs,
    FY2022UsageBySubjectOnlineISSNs
], ignore_index=True)

len(FY2022MathUsage)

FY2022MathUsage.columns

columns_to_drop = ['Title', 'SUM([Reporting_Period_Total])']
FY2022MathUsage = FY2022MathUsage.drop(columns=columns_to_drop, axis=1)

FY2022MathUsage.to_sql('FY2022MathUsage', conn, if_exists='replace', index=False)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in FY2022MathUsage.columns:
    ocns_to_exclude.update(FY2022MathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in FY2022MathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(FY2022MathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in FY2022MathUsage.")


isbns_to_exclude = set()
if 'ISBN' in FY2022MathUsage.columns:
    isbns_to_exclude.update(FY2022MathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in FY2022MathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
FY2022MathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
FY2022MathNonUsage = FY2022MathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in FY2022MathNonUsage: {len(FY2022MathNonUsage)}")

FinalFY2022MathUsageData = pd.concat([FY2022MathUsage, FY2022MathNonUsage], ignore_index=True)

FinalFY2022MathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalFY2022MathUsageData.xlsx')

FY2023UsagebySubjectonOCN = FY2023UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = FY2023UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
FY2023UsagebySubjectonOCN = FY2023UsagebySubjectonOCN[current_columns]

FY2023UsageBySubjectPrintISSNs = FY2023UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

FY2023UsageBySubjectOnlineISSNs = FY2023UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

FY2023UsageBySubjectOnlineISSNs.columns

FY2023UsageBySubjectPrintISSNs = FY2023UsageBySubjectPrintISSNs.loc[:,~FY2023UsageBySubjectPrintISSNs.columns.duplicated()]
FY2023UsageBySubjectOnlineISSNs = FY2023UsageBySubjectOnlineISSNs.loc[:,~FY2023UsageBySubjectOnlineISSNs.columns.duplicated()]

FY2023MathUsage = pd.concat([
    FY2023UsagebySubjectonOCN,
    FY2023UsagebySubjectNoOCNs,
    FY2023UsageBySubjectPrintISSNs,
    FY2023UsageBySubjectOnlineISSNs
], ignore_index=True)

len(FY2023MathUsage)

FY2023MathUsage.columns

columns_to_drop = ['Title', 'SUM([Reporting_Period_Total])']
FY2023MathUsage = FY2023MathUsage.drop(columns=columns_to_drop, axis=1)

FY2023MathUsage.to_sql('FY2023MathUsage', conn, if_exists='replace', index=False)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in FY2023MathUsage.columns:
    ocns_to_exclude.update(FY2023MathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in FY2023MathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(FY2023MathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in FY2023MathUsage.")


isbns_to_exclude = set()
if 'ISBN' in FY2023MathUsage.columns:
    isbns_to_exclude.update(FY2023MathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in FY2023MathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
FY2023MathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
FY2023MathNonUsage = FY2023MathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in FY2023MathNonUsage: {len(FY2023MathNonUsage)}")

FinalFY2023MathUsageData = pd.concat([FY2023MathUsage, FY2023MathNonUsage], ignore_index=True)

FinalFY2023MathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalFY2023MathUsageData.xlsx')

FY2024UsagebySubjectonOCN = FY2024UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = FY2024UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
FY2024UsagebySubjectonOCN = FY2024UsagebySubjectonOCN[current_columns]

FY2024UsageBySubjectPrintISSNs = FY2024UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

FY2024UsageBySubjectOnlineISSNs = FY2024UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

FY2024UsageBySubjectOnlineISSNs.columns

FY2024UsageBySubjectPrintISSNs = FY2024UsageBySubjectPrintISSNs.loc[:,~FY2024UsageBySubjectPrintISSNs.columns.duplicated()]
FY2024UsageBySubjectOnlineISSNs = FY2024UsageBySubjectOnlineISSNs.loc[:,~FY2024UsageBySubjectOnlineISSNs.columns.duplicated()]

FY2024MathUsage = pd.concat([
    FY2024UsagebySubjectonOCN,
    FY2024UsagebySubjectNoOCNs,
    FY2024UsageBySubjectPrintISSNs,
    FY2024UsageBySubjectOnlineISSNs
], ignore_index=True)

len(FY2024MathUsage)

FY2024MathUsage.columns

columns_to_drop = ['Title', 'SUM([Reporting_Period_Total])']
FY2024MathUsage = FY2024MathUsage.drop(columns=columns_to_drop, axis=1)

FY2024MathUsage.to_sql('FY2024MathUsage', conn, if_exists='replace', index=False)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in FY2024MathUsage.columns:
    ocns_to_exclude.update(FY2024MathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in FY2024MathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(FY2024MathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in FY2024MathUsage.")


isbns_to_exclude = set()
if 'ISBN' in FY2024MathUsage.columns:
    isbns_to_exclude.update(FY2024MathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in FY2024MathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
FY2024MathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
FY2024MathNonUsage = FY2024MathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in FY2024MathNonUsage: {len(FY2024MathNonUsage)}")

FinalFY2024MathUsageData = pd.concat([FY2024MathUsage, FY2024MathNonUsage], ignore_index=True)

FinalFY2024MathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalFY2024MathUsageData.xlsx')

FY2025UsagebySubjectonOCN = FY2025UsagebySubjectonOCN.drop(columns=['oclc_number', 'publication_title'])

# Get the current list of columns
current_columns = FY2025UsagebySubjectonOCN.columns.tolist()

# Find the index of the columns you want to move and insert
metric_type_col = 'Metric_Type'
print_issn_col = 'Print_ISSN'
reporting_period_total_col = 'Reporting_Period_Total'

# Remove Metric_Type from its current position
current_columns.remove(metric_type_col)

# Find the index where you want to insert Metric_Type (after Print_ISSN)
try:
    insert_index = current_columns.index(print_issn_col) + 1
except ValueError:
    # If Print_ISSN is not found, insert before Reporting_Period_Total
    try:
        insert_index = current_columns.index(reporting_period_total_col)
    except ValueError:
        # If neither is found, append to the end
        insert_index = len(current_columns)

# Insert Metric_Type at the calculated index
current_columns.insert(insert_index, metric_type_col)

# Reindex the DataFrame with the new column order
FY2025UsagebySubjectonOCN = FY2025UsagebySubjectonOCN[current_columns]

FY2025UsageBySubjectPrintISSNs = FY2025UsageBySubjectPrintISSNs.drop(columns=['publication_title'])

FY2025UsageBySubjectOnlineISSNs = FY2025UsageBySubjectOnlineISSNs.drop(columns=['publication_title'])

FY2025UsageBySubjectOnlineISSNs.columns

FY2025UsageBySubjectPrintISSNs = FY2025UsageBySubjectPrintISSNs.loc[:,~FY2025UsageBySubjectPrintISSNs.columns.duplicated()]
FY2025UsageBySubjectOnlineISSNs = FY2025UsageBySubjectOnlineISSNs.loc[:,~FY2025UsageBySubjectOnlineISSNs.columns.duplicated()]

FY2025MathUsage = pd.concat([
    FY2025UsagebySubjectonOCN,
    FY2025UsagebySubjectNoOCNs,
    FY2025UsageBySubjectPrintISSNs,
    FY2025UsageBySubjectOnlineISSNs
], ignore_index=True)

len(FY2025MathUsage)

FY2025MathUsage.columns

columns_to_drop = ['Title', 'SUM([Reporting_Period_Total])']
FY2025MathUsage = FY2025MathUsage.drop(columns=columns_to_drop, axis=1)

FY2025MathUsage.to_sql('FY2025MathUsage', conn, if_exists='replace', index=False)

# Assuming SubjectDatawithISBNandISSN and AllMathUsage DataFrames are already loaded

# --- Step 1: Get the sets of OCNs and ISBNs to exclude ---
# Ensure the columns exist and convert to string type and get unique values
ocns_to_exclude = set()
if 'OCN' in FY2025MathUsage.columns:
    ocns_to_exclude.update(FY2025MathUsage['OCN'].astype(str).dropna().unique())
elif 'oclc_number' in FY2025MathUsage.columns: # Check alternative column name
    ocns_to_exclude.update(FY2025MathUsage['oclc_number'].astype(str).dropna().unique())
else:
    print("Warning: Neither 'OCN' nor 'oclc_number' column found in FY2025MathUsage.")


isbns_to_exclude = set()
if 'ISBN' in FY2025MathUsage.columns:
    isbns_to_exclude.update(FY2025MathUsage['ISBN'].astype(str).dropna().unique())
else:
     print("Warning: 'ISBN' column not found in FY2025MathUsage.")


# Ensure SubjectDatawithISBNandISSN['OCN'] and ['sISBN'] are string for comparison
SubjectDatawithISBNandISSN['OCN'] = SubjectDatawithISBNandISSN['OCN'].astype(str)
SubjectDatawithISBNandISSN['sISBN'] = SubjectDatawithISBNandISSN['sISBN'].astype(str)

# --- Step 2: Identify rows in SubjectDatawithISBNandISSN that should be removed ---

# Rows to remove based on OCN match
# .isin() checks if each OCN in SubjectDatawithISBNandISSN is in the set of ocns_to_exclude
ocn_matches = SubjectDatawithISBNandISSN['OCN'].isin(ocns_to_exclude)

# Rows to remove based on sISBN match
# .isin() checks if each sISBN in SubjectDatawithISBNandISSN is in the set of isbns_to_exclude
isbn_matches = SubjectDatawithISBNandISSN['sISBN'].isin(isbns_to_exclude)

# A row should be removed if it matches on OCN OR sISBN
rows_to_remove = ocn_matches | isbn_matches # Use '|' for logical OR for boolean Series

# --- Step 3: Select the rows that are NOT to be removed ---
# Use boolean indexing with '~' (logical NOT) to select the complement of rows_to_remove
FY2025MathNonUsage = SubjectDatawithISBNandISSN[~rows_to_remove].copy() # Use .copy() to avoid SettingWithCopyWarning

# --- Step 4: Reset the index for the new DataFrame ---
FY2025MathNonUsage = FY2025MathNonUsage.reset_index(drop=True)

# Print the count of the resulting DataFrame
print(f"Number of rows in FY2025MathNonUsage: {len(FY2025MathNonUsage)}")

FinalFY2025MathUsageData = pd.concat([FY2025MathUsage, FY2025MathNonUsage], ignore_index=True)

FinalFY2025MathUsageData.to_excel('/content/drive/My Drive/Data Services/Collections Assessments/Math2025KBARTData/FinalFY2025MathUsageData.xlsx')